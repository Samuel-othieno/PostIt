'use client';
import { jsx, jsxs } from 'react/jsx-runtime';
import { useState } from 'react';
import { ReferenceLine, Scatter, ResponsiveContainer, ScatterChart as ScatterChart$1, CartesianGrid, XAxis, Label, YAxis, Tooltip, Legend } from 'recharts';
import { createVarsResolver, getThemeColor, factory, useProps, useMantineTheme, useResolvedStylesApi, useStyles, Box } from '@mantine/core';
import { ChartLegend } from '../ChartLegend/ChartLegend.mjs';
import { ChartTooltip } from '../ChartTooltip/ChartTooltip.mjs';
import classes from '../grid-chart.module.css.mjs';

function getAxis(key, dataKey) {
  return key === dataKey.x ? "x" : "y";
}
const defaultProps = {
  withXAxis: true,
  withYAxis: true,
  withTooltip: true,
  tooltipAnimationDuration: 0,
  tickLine: "y",
  strokeDasharray: "5 5",
  gridAxis: "x"
};
const varsResolver = createVarsResolver((theme, { textColor, gridColor }) => ({
  root: {
    "--chart-text-color": textColor ? getThemeColor(textColor, theme) : void 0,
    "--chart-grid-color": gridColor ? getThemeColor(gridColor, theme) : void 0
  }
}));
const ScatterChart = factory((_props, ref) => {
  const props = useProps("ScatterChart", defaultProps, _props);
  const {
    classNames,
    className,
    style,
    styles,
    unstyled,
    vars,
    referenceLines,
    dir,
    withLegend,
    withTooltip,
    withXAxis,
    withYAxis,
    xAxisProps,
    yAxisProps,
    orientation,
    scatterChartProps,
    legendProps,
    data,
    gridAxis,
    tickLine,
    strokeDasharray,
    gridProps,
    tooltipAnimationDuration,
    tooltipProps,
    children,
    onMouseLeave,
    dataKey,
    textColor,
    gridColor,
    xAxisLabel,
    yAxisLabel,
    unit,
    labels,
    valueFormatter,
    scatterProps,
    ...others
  } = props;
  const getFormatter = (axis) => typeof valueFormatter === "function" ? valueFormatter : valueFormatter?.[axis];
  const xFormatter = getFormatter("x");
  const yFormatter = getFormatter("y");
  const theme = useMantineTheme();
  const mappedData = data.map((item) => ({
    ...item,
    data: item.data.map((point) => ({ ...point, name: item.name }))
  }));
  const { resolvedClassNames, resolvedStyles } = useResolvedStylesApi({
    classNames,
    styles,
    props
  });
  const getStyles = useStyles({
    name: "ScatterChart",
    classes,
    props,
    className,
    style,
    classNames,
    styles,
    unstyled,
    vars,
    varsResolver
  });
  const withXTickLine = gridAxis !== "none" && (tickLine === "x" || tickLine === "xy");
  const withYTickLine = gridAxis !== "none" && (tickLine === "y" || tickLine === "xy");
  const [highlightedArea, setHighlightedArea] = useState(null);
  const shouldHighlight = highlightedArea !== null;
  const handleMouseLeave = (event) => {
    setHighlightedArea(null);
    onMouseLeave?.(event);
  };
  const referenceLinesItems = referenceLines?.map((line, index) => {
    const color = getThemeColor(line.color, theme);
    return /* @__PURE__ */ jsx(
      ReferenceLine,
      {
        stroke: line.color ? color : "var(--chart-grid-color)",
        strokeWidth: 1,
        ...line,
        label: {
          value: line.label,
          fill: line.color ? color : "currentColor",
          fontSize: 12,
          position: line.labelPosition ?? "insideBottomLeft"
        },
        ...getStyles("referenceLine")
      },
      index
    );
  });
  const scatters = mappedData.map((item, index) => {
    const dimmed = shouldHighlight && highlightedArea !== item.name;
    return /* @__PURE__ */ jsx(
      Scatter,
      {
        data: item.data,
        fill: getThemeColor(item.color, theme),
        isAnimationActive: false,
        fillOpacity: dimmed ? 0.1 : 1,
        ...scatterProps
      },
      index
    );
  });
  return /* @__PURE__ */ jsx(
    Box,
    {
      ref,
      ...getStyles("root"),
      onMouseLeave: handleMouseLeave,
      dir: dir || "ltr",
      ...others,
      children: /* @__PURE__ */ jsx(ResponsiveContainer, { ...getStyles("container"), children: /* @__PURE__ */ jsxs(
        ScatterChart$1,
        {
          margin: {
            bottom: xAxisLabel ? 30 : void 0,
            left: yAxisLabel ? 10 : void 0,
            right: yAxisLabel ? 5 : void 0
          },
          ...scatterChartProps,
          children: [
            /* @__PURE__ */ jsx(
              CartesianGrid,
              {
                strokeDasharray,
                vertical: gridAxis === "y" || gridAxis === "xy",
                horizontal: gridAxis === "x" || gridAxis === "xy",
                ...getStyles("grid"),
                ...gridProps
              }
            ),
            /* @__PURE__ */ jsxs(
              XAxis,
              {
                type: "number",
                hide: !withXAxis,
                dataKey: dataKey.x,
                tick: { transform: "translate(0, 10)", fontSize: 12, fill: "currentColor" },
                stroke: "",
                interval: "preserveStartEnd",
                tickLine: withXTickLine ? { stroke: "currentColor" } : false,
                minTickGap: 5,
                unit: unit?.x,
                tickFormatter: xFormatter,
                ...getStyles("axis"),
                ...xAxisProps,
                children: [
                  xAxisLabel && /* @__PURE__ */ jsx(Label, { position: "insideBottom", offset: -20, fontSize: 12, ...getStyles("axisLabel"), children: xAxisLabel }),
                  xAxisProps?.children
                ]
              }
            ),
            /* @__PURE__ */ jsxs(
              YAxis,
              {
                type: "number",
                hide: !withYAxis,
                axisLine: false,
                dataKey: dataKey.y,
                tickLine: withYTickLine ? { stroke: "currentColor" } : false,
                tick: { transform: "translate(-10, 0)", fontSize: 12, fill: "currentColor" },
                allowDecimals: true,
                unit: unit?.y,
                tickFormatter: yFormatter,
                ...getStyles("axis"),
                ...yAxisProps,
                children: [
                  yAxisLabel && /* @__PURE__ */ jsx(
                    Label,
                    {
                      position: "insideLeft",
                      angle: -90,
                      textAnchor: "middle",
                      fontSize: 12,
                      offset: -5,
                      ...getStyles("axisLabel"),
                      children: yAxisLabel
                    }
                  ),
                  yAxisProps?.children
                ]
              }
            ),
            withTooltip && /* @__PURE__ */ jsx(
              Tooltip,
              {
                animationDuration: tooltipAnimationDuration,
                isAnimationActive: tooltipAnimationDuration !== 0,
                position: { y: 0 },
                cursor: {
                  stroke: "var(--chart-grid-color)",
                  strokeWidth: 1,
                  strokeDasharray
                },
                content: ({ label, payload }) => /* @__PURE__ */ jsx(
                  ChartTooltip,
                  {
                    type: "scatter",
                    label,
                    payload: labels ? payload?.map((item) => ({
                      ...item,
                      name: labels[getAxis(item.name, dataKey)] || item.name,
                      value: getFormatter(getAxis(item.name, dataKey))?.(item.value) ?? item.value
                    })) : payload?.map((item) => ({
                      ...item,
                      value: getFormatter(getAxis(item.name, dataKey))?.(item.value) ?? item.value
                    })),
                    classNames: resolvedClassNames,
                    styles: resolvedStyles,
                    series: data
                  }
                ),
                ...tooltipProps
              }
            ),
            withLegend && /* @__PURE__ */ jsx(
              Legend,
              {
                verticalAlign: "top",
                content: (payload) => /* @__PURE__ */ jsx(
                  ChartLegend,
                  {
                    payload: payload.payload?.map((item, index) => ({
                      ...item,
                      dataKey: data[index].name
                    })),
                    onHighlight: setHighlightedArea,
                    legendPosition: legendProps?.verticalAlign || "top",
                    classNames: resolvedClassNames,
                    styles: resolvedStyles,
                    series: data
                  }
                ),
                height: 44,
                ...legendProps
              }
            ),
            referenceLinesItems,
            scatters
          ]
        }
      ) })
    }
  );
});
ScatterChart.displayName = "@mantine/charts/ScatterChart";
ScatterChart.classes = classes;

export { ScatterChart };
//# sourceMappingURL=ScatterChart.mjs.map
