(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@tiptap/extension-bubble-menu'), require('react'), require('react-dom'), require('@tiptap/core'), require('@tiptap/extension-floating-menu')) :
  typeof define === 'function' && define.amd ? define(['exports', '@tiptap/extension-bubble-menu', 'react', 'react-dom', '@tiptap/core', '@tiptap/extension-floating-menu'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global["@tiptap/react"] = {}, global.extensionBubbleMenu, global.React, global.ReactDOM, global.core, global.extensionFloatingMenu));
})(this, (function (exports, extensionBubbleMenu, React, ReactDOM, core, extensionFloatingMenu) { 'use strict';

  const mergeRefs = (...refs) => {
      return (node) => {
          refs.forEach(ref => {
              if (typeof ref === 'function') {
                  ref(node);
              }
              else if (ref) {
                  ref.current = node;
              }
          });
      };
  };
  const Portals = ({ renderers }) => {
      return (React.createElement(React.Fragment, null, Object.entries(renderers).map(([key, renderer]) => {
          return ReactDOM.createPortal(renderer.reactElement, renderer.element, key);
      })));
  };
  class PureEditorContent extends React.Component {
      constructor(props) {
          super(props);
          this.editorContentRef = React.createRef();
          this.initialized = false;
          this.state = {
              renderers: {},
          };
      }
      componentDidMount() {
          this.init();
      }
      componentDidUpdate() {
          this.init();
      }
      init() {
          const { editor } = this.props;
          if (editor && !editor.isDestroyed && editor.options.element) {
              if (editor.contentComponent) {
                  return;
              }
              const element = this.editorContentRef.current;
              element.append(...editor.options.element.childNodes);
              editor.setOptions({
                  element,
              });
              editor.contentComponent = this;
              editor.createNodeViews();
              this.initialized = true;
          }
      }
      maybeFlushSync(fn) {
          // Avoid calling flushSync until the editor is initialized.
          // Initialization happens during the componentDidMount or componentDidUpdate
          // lifecycle methods, and React doesn't allow calling flushSync from inside
          // a lifecycle method.
          if (this.initialized) {
              ReactDOM.flushSync(fn);
          }
          else {
              fn();
          }
      }
      setRenderer(id, renderer) {
          this.maybeFlushSync(() => {
              this.setState(({ renderers }) => ({
                  renderers: {
                      ...renderers,
                      [id]: renderer,
                  },
              }));
          });
      }
      removeRenderer(id) {
          this.maybeFlushSync(() => {
              this.setState(({ renderers }) => {
                  const nextRenderers = { ...renderers };
                  delete nextRenderers[id];
                  return { renderers: nextRenderers };
              });
          });
      }
      componentWillUnmount() {
          const { editor } = this.props;
          if (!editor) {
              return;
          }
          this.initialized = false;
          if (!editor.isDestroyed) {
              editor.view.setProps({
                  nodeViews: {},
              });
          }
          editor.contentComponent = null;
          if (!editor.options.element.firstChild) {
              return;
          }
          const newElement = document.createElement('div');
          newElement.append(...editor.options.element.childNodes);
          editor.setOptions({
              element: newElement,
          });
      }
      render() {
          const { editor, innerRef, ...rest } = this.props;
          return (React.createElement(React.Fragment, null,
              React.createElement("div", { ref: mergeRefs(innerRef, this.editorContentRef), ...rest }),
              React.createElement(Portals, { renderers: this.state.renderers })));
      }
  }
  // EditorContent should be re-created whenever the Editor instance changes
  const EditorContentWithKey = React.forwardRef((props, ref) => {
      const key = React.useMemo(() => {
          return Math.floor(Math.random() * 0xFFFFFFFF).toString();
      }, [props.editor]);
      // Can't use JSX here because it conflicts with the type definition of Vue's JSX, so use createElement
      return React.createElement(PureEditorContent, {
          key,
          innerRef: ref,
          ...props,
      });
  });
  const EditorContent = React.memo(EditorContentWithKey);

  class Editor extends core.Editor {
      constructor() {
          super(...arguments);
          this.contentComponent = null;
      }
  }

  var withSelector = {exports: {}};

  var withSelector_production_min = {};

  var shim = {exports: {}};

  var useSyncExternalStoreShim_production_min = {};

  /**
   * @license React
   * use-sync-external-store-shim.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  var hasRequiredUseSyncExternalStoreShim_production_min;

  function requireUseSyncExternalStoreShim_production_min () {
  	if (hasRequiredUseSyncExternalStoreShim_production_min) return useSyncExternalStoreShim_production_min;
  	hasRequiredUseSyncExternalStoreShim_production_min = 1;
  var e=React;function h(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}var k="function"===typeof Object.is?Object.is:h,l=e.useState,m=e.useEffect,n=e.useLayoutEffect,p=e.useDebugValue;function q(a,b){var d=b(),f=l({inst:{value:d,getSnapshot:b}}),c=f[0].inst,g=f[1];n(function(){c.value=d;c.getSnapshot=b;r(c)&&g({inst:c});},[a,d,b]);m(function(){r(c)&&g({inst:c});return a(function(){r(c)&&g({inst:c});})},[a]);p(d);return d}
  	function r(a){var b=a.getSnapshot;a=a.value;try{var d=b();return !k(a,d)}catch(f){return !0}}function t(a,b){return b()}var u="undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement?t:q;useSyncExternalStoreShim_production_min.useSyncExternalStore=void 0!==e.useSyncExternalStore?e.useSyncExternalStore:u;
  	return useSyncExternalStoreShim_production_min;
  }

  var useSyncExternalStoreShim_development = {};

  /**
   * @license React
   * use-sync-external-store-shim.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  var hasRequiredUseSyncExternalStoreShim_development;

  function requireUseSyncExternalStoreShim_development () {
  	if (hasRequiredUseSyncExternalStoreShim_development) return useSyncExternalStoreShim_development;
  	hasRequiredUseSyncExternalStoreShim_development = 1;

  	if (process.env.NODE_ENV !== "production") {
  	  (function() {

  	/* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
  	if (
  	  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' &&
  	  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart ===
  	    'function'
  	) {
  	  __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
  	}
  	          var React$1 = React;

  	var ReactSharedInternals = React$1.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;

  	function error(format) {
  	  {
  	    {
  	      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
  	        args[_key2 - 1] = arguments[_key2];
  	      }

  	      printWarning('error', format, args);
  	    }
  	  }
  	}

  	function printWarning(level, format, args) {
  	  // When changing this logic, you might want to also
  	  // update consoleWithStackDev.www.js as well.
  	  {
  	    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
  	    var stack = ReactDebugCurrentFrame.getStackAddendum();

  	    if (stack !== '') {
  	      format += '%s';
  	      args = args.concat([stack]);
  	    } // eslint-disable-next-line react-internal/safe-string-coercion


  	    var argsWithFormat = args.map(function (item) {
  	      return String(item);
  	    }); // Careful: RN currently depends on this prefix

  	    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it
  	    // breaks IE9: https://github.com/facebook/react/issues/13610
  	    // eslint-disable-next-line react-internal/no-production-logging

  	    Function.prototype.apply.call(console[level], console, argsWithFormat);
  	  }
  	}

  	/**
  	 * inlined Object.is polyfill to avoid requiring consumers ship their own
  	 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
  	 */
  	function is(x, y) {
  	  return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y // eslint-disable-line no-self-compare
  	  ;
  	}

  	var objectIs = typeof Object.is === 'function' ? Object.is : is;

  	// dispatch for CommonJS interop named imports.

  	var useState = React$1.useState,
  	    useEffect = React$1.useEffect,
  	    useLayoutEffect = React$1.useLayoutEffect,
  	    useDebugValue = React$1.useDebugValue;
  	var didWarnOld18Alpha = false;
  	var didWarnUncachedGetSnapshot = false; // Disclaimer: This shim breaks many of the rules of React, and only works
  	// because of a very particular set of implementation details and assumptions
  	// -- change any one of them and it will break. The most important assumption
  	// is that updates are always synchronous, because concurrent rendering is
  	// only available in versions of React that also have a built-in
  	// useSyncExternalStore API. And we only use this shim when the built-in API
  	// does not exist.
  	//
  	// Do not assume that the clever hacks used by this hook also work in general.
  	// The point of this shim is to replace the need for hacks by other libraries.

  	function useSyncExternalStore(subscribe, getSnapshot, // Note: The shim does not use getServerSnapshot, because pre-18 versions of
  	// React do not expose a way to check if we're hydrating. So users of the shim
  	// will need to track that themselves and return the correct value
  	// from `getSnapshot`.
  	getServerSnapshot) {
  	  {
  	    if (!didWarnOld18Alpha) {
  	      if (React$1.startTransition !== undefined) {
  	        didWarnOld18Alpha = true;

  	        error('You are using an outdated, pre-release alpha of React 18 that ' + 'does not support useSyncExternalStore. The ' + 'use-sync-external-store shim will not work correctly. Upgrade ' + 'to a newer pre-release.');
  	      }
  	    }
  	  } // Read the current snapshot from the store on every render. Again, this
  	  // breaks the rules of React, and only works here because of specific
  	  // implementation details, most importantly that updates are
  	  // always synchronous.


  	  var value = getSnapshot();

  	  {
  	    if (!didWarnUncachedGetSnapshot) {
  	      var cachedValue = getSnapshot();

  	      if (!objectIs(value, cachedValue)) {
  	        error('The result of getSnapshot should be cached to avoid an infinite loop');

  	        didWarnUncachedGetSnapshot = true;
  	      }
  	    }
  	  } // Because updates are synchronous, we don't queue them. Instead we force a
  	  // re-render whenever the subscribed state changes by updating an some
  	  // arbitrary useState hook. Then, during render, we call getSnapshot to read
  	  // the current value.
  	  //
  	  // Because we don't actually use the state returned by the useState hook, we
  	  // can save a bit of memory by storing other stuff in that slot.
  	  //
  	  // To implement the early bailout, we need to track some things on a mutable
  	  // object. Usually, we would put that in a useRef hook, but we can stash it in
  	  // our useState hook instead.
  	  //
  	  // To force a re-render, we call forceUpdate({inst}). That works because the
  	  // new object always fails an equality check.


  	  var _useState = useState({
  	    inst: {
  	      value: value,
  	      getSnapshot: getSnapshot
  	    }
  	  }),
  	      inst = _useState[0].inst,
  	      forceUpdate = _useState[1]; // Track the latest getSnapshot function with a ref. This needs to be updated
  	  // in the layout phase so we can access it during the tearing check that
  	  // happens on subscribe.


  	  useLayoutEffect(function () {
  	    inst.value = value;
  	    inst.getSnapshot = getSnapshot; // Whenever getSnapshot or subscribe changes, we need to check in the
  	    // commit phase if there was an interleaved mutation. In concurrent mode
  	    // this can happen all the time, but even in synchronous mode, an earlier
  	    // effect may have mutated the store.

  	    if (checkIfSnapshotChanged(inst)) {
  	      // Force a re-render.
  	      forceUpdate({
  	        inst: inst
  	      });
  	    }
  	  }, [subscribe, value, getSnapshot]);
  	  useEffect(function () {
  	    // Check for changes right before subscribing. Subsequent changes will be
  	    // detected in the subscription handler.
  	    if (checkIfSnapshotChanged(inst)) {
  	      // Force a re-render.
  	      forceUpdate({
  	        inst: inst
  	      });
  	    }

  	    var handleStoreChange = function () {
  	      // TODO: Because there is no cross-renderer API for batching updates, it's
  	      // up to the consumer of this library to wrap their subscription event
  	      // with unstable_batchedUpdates. Should we try to detect when this isn't
  	      // the case and print a warning in development?
  	      // The store changed. Check if the snapshot changed since the last time we
  	      // read from the store.
  	      if (checkIfSnapshotChanged(inst)) {
  	        // Force a re-render.
  	        forceUpdate({
  	          inst: inst
  	        });
  	      }
  	    }; // Subscribe to the store and return a clean-up function.


  	    return subscribe(handleStoreChange);
  	  }, [subscribe]);
  	  useDebugValue(value);
  	  return value;
  	}

  	function checkIfSnapshotChanged(inst) {
  	  var latestGetSnapshot = inst.getSnapshot;
  	  var prevValue = inst.value;

  	  try {
  	    var nextValue = latestGetSnapshot();
  	    return !objectIs(prevValue, nextValue);
  	  } catch (error) {
  	    return true;
  	  }
  	}

  	function useSyncExternalStore$1(subscribe, getSnapshot, getServerSnapshot) {
  	  // Note: The shim does not use getServerSnapshot, because pre-18 versions of
  	  // React do not expose a way to check if we're hydrating. So users of the shim
  	  // will need to track that themselves and return the correct value
  	  // from `getSnapshot`.
  	  return getSnapshot();
  	}

  	var canUseDOM = !!(typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined');

  	var isServerEnvironment = !canUseDOM;

  	var shim = isServerEnvironment ? useSyncExternalStore$1 : useSyncExternalStore;
  	var useSyncExternalStore$2 = React$1.useSyncExternalStore !== undefined ? React$1.useSyncExternalStore : shim;

  	useSyncExternalStoreShim_development.useSyncExternalStore = useSyncExternalStore$2;
  	          /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
  	if (
  	  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' &&
  	  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop ===
  	    'function'
  	) {
  	  __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
  	}
  	        
  	  })();
  	}
  	return useSyncExternalStoreShim_development;
  }

  var hasRequiredShim;

  function requireShim () {
  	if (hasRequiredShim) return shim.exports;
  	hasRequiredShim = 1;

  	if (process.env.NODE_ENV === 'production') {
  	  shim.exports = requireUseSyncExternalStoreShim_production_min();
  	} else {
  	  shim.exports = requireUseSyncExternalStoreShim_development();
  	}
  	return shim.exports;
  }

  /**
   * @license React
   * use-sync-external-store-shim/with-selector.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  var hasRequiredWithSelector_production_min;

  function requireWithSelector_production_min () {
  	if (hasRequiredWithSelector_production_min) return withSelector_production_min;
  	hasRequiredWithSelector_production_min = 1;
  var h=React,n=requireShim();function p(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}var q="function"===typeof Object.is?Object.is:p,r=n.useSyncExternalStore,t=h.useRef,u=h.useEffect,v=h.useMemo,w=h.useDebugValue;
  	withSelector_production_min.useSyncExternalStoreWithSelector=function(a,b,e,l,g){var c=t(null);if(null===c.current){var f={hasValue:!1,value:null};c.current=f;}else f=c.current;c=v(function(){function a(a){if(!c){c=!0;d=a;a=l(a);if(void 0!==g&&f.hasValue){var b=f.value;if(g(b,a))return k=b}return k=a}b=k;if(q(d,a))return b;var e=l(a);if(void 0!==g&&g(b,e))return b;d=a;return k=e}var c=!1,d,k,m=void 0===e?null:e;return [function(){return a(b())},null===m?void 0:function(){return a(m())}]},[b,e,l,g]);var d=r(a,c[0],c[1]);
  	u(function(){f.hasValue=!0;f.value=d;},[d]);w(d);return d};
  	return withSelector_production_min;
  }

  var withSelector_development = {};

  /**
   * @license React
   * use-sync-external-store-shim/with-selector.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */

  var hasRequiredWithSelector_development;

  function requireWithSelector_development () {
  	if (hasRequiredWithSelector_development) return withSelector_development;
  	hasRequiredWithSelector_development = 1;

  	if (process.env.NODE_ENV !== "production") {
  	  (function() {

  	/* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
  	if (
  	  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' &&
  	  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart ===
  	    'function'
  	) {
  	  __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
  	}
  	          var React$1 = React;
  	var shim = requireShim();

  	/**
  	 * inlined Object.is polyfill to avoid requiring consumers ship their own
  	 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
  	 */
  	function is(x, y) {
  	  return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y // eslint-disable-line no-self-compare
  	  ;
  	}

  	var objectIs = typeof Object.is === 'function' ? Object.is : is;

  	var useSyncExternalStore = shim.useSyncExternalStore;

  	// for CommonJS interop.

  	var useRef = React$1.useRef,
  	    useEffect = React$1.useEffect,
  	    useMemo = React$1.useMemo,
  	    useDebugValue = React$1.useDebugValue; // Same as useSyncExternalStore, but supports selector and isEqual arguments.

  	function useSyncExternalStoreWithSelector(subscribe, getSnapshot, getServerSnapshot, selector, isEqual) {
  	  // Use this to track the rendered snapshot.
  	  var instRef = useRef(null);
  	  var inst;

  	  if (instRef.current === null) {
  	    inst = {
  	      hasValue: false,
  	      value: null
  	    };
  	    instRef.current = inst;
  	  } else {
  	    inst = instRef.current;
  	  }

  	  var _useMemo = useMemo(function () {
  	    // Track the memoized state using closure variables that are local to this
  	    // memoized instance of a getSnapshot function. Intentionally not using a
  	    // useRef hook, because that state would be shared across all concurrent
  	    // copies of the hook/component.
  	    var hasMemo = false;
  	    var memoizedSnapshot;
  	    var memoizedSelection;

  	    var memoizedSelector = function (nextSnapshot) {
  	      if (!hasMemo) {
  	        // The first time the hook is called, there is no memoized result.
  	        hasMemo = true;
  	        memoizedSnapshot = nextSnapshot;

  	        var _nextSelection = selector(nextSnapshot);

  	        if (isEqual !== undefined) {
  	          // Even if the selector has changed, the currently rendered selection
  	          // may be equal to the new selection. We should attempt to reuse the
  	          // current value if possible, to preserve downstream memoizations.
  	          if (inst.hasValue) {
  	            var currentSelection = inst.value;

  	            if (isEqual(currentSelection, _nextSelection)) {
  	              memoizedSelection = currentSelection;
  	              return currentSelection;
  	            }
  	          }
  	        }

  	        memoizedSelection = _nextSelection;
  	        return _nextSelection;
  	      } // We may be able to reuse the previous invocation's result.


  	      // We may be able to reuse the previous invocation's result.
  	      var prevSnapshot = memoizedSnapshot;
  	      var prevSelection = memoizedSelection;

  	      if (objectIs(prevSnapshot, nextSnapshot)) {
  	        // The snapshot is the same as last time. Reuse the previous selection.
  	        return prevSelection;
  	      } // The snapshot has changed, so we need to compute a new selection.


  	      // The snapshot has changed, so we need to compute a new selection.
  	      var nextSelection = selector(nextSnapshot); // If a custom isEqual function is provided, use that to check if the data
  	      // has changed. If it hasn't, return the previous selection. That signals
  	      // to React that the selections are conceptually equal, and we can bail
  	      // out of rendering.

  	      // If a custom isEqual function is provided, use that to check if the data
  	      // has changed. If it hasn't, return the previous selection. That signals
  	      // to React that the selections are conceptually equal, and we can bail
  	      // out of rendering.
  	      if (isEqual !== undefined && isEqual(prevSelection, nextSelection)) {
  	        return prevSelection;
  	      }

  	      memoizedSnapshot = nextSnapshot;
  	      memoizedSelection = nextSelection;
  	      return nextSelection;
  	    }; // Assigning this to a constant so that Flow knows it can't change.


  	    // Assigning this to a constant so that Flow knows it can't change.
  	    var maybeGetServerSnapshot = getServerSnapshot === undefined ? null : getServerSnapshot;

  	    var getSnapshotWithSelector = function () {
  	      return memoizedSelector(getSnapshot());
  	    };

  	    var getServerSnapshotWithSelector = maybeGetServerSnapshot === null ? undefined : function () {
  	      return memoizedSelector(maybeGetServerSnapshot());
  	    };
  	    return [getSnapshotWithSelector, getServerSnapshotWithSelector];
  	  }, [getSnapshot, getServerSnapshot, selector, isEqual]),
  	      getSelection = _useMemo[0],
  	      getServerSelection = _useMemo[1];

  	  var value = useSyncExternalStore(subscribe, getSelection, getServerSelection);
  	  useEffect(function () {
  	    inst.hasValue = true;
  	    inst.value = value;
  	  }, [value]);
  	  useDebugValue(value);
  	  return value;
  	}

  	withSelector_development.useSyncExternalStoreWithSelector = useSyncExternalStoreWithSelector;
  	          /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
  	if (
  	  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' &&
  	  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop ===
  	    'function'
  	) {
  	  __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
  	}
  	        
  	  })();
  	}
  	return withSelector_development;
  }

  if (process.env.NODE_ENV === 'production') {
    withSelector.exports = requireWithSelector_production_min();
  } else {
    withSelector.exports = requireWithSelector_development();
  }

  var withSelectorExports = withSelector.exports;

  /**
   * To synchronize the editor instance with the component state,
   * we need to create a separate instance that is not affected by the component re-renders.
   */
  function makeEditorStateInstance(initialEditor) {
      let transactionNumber = 0;
      let lastTransactionNumber = 0;
      let lastSnapshot = { editor: initialEditor, transactionNumber: 0 };
      let editor = initialEditor;
      const subscribers = new Set();
      const editorInstance = {
          /**
           * Get the current editor instance.
           */
          getSnapshot() {
              if (transactionNumber === lastTransactionNumber) {
                  return lastSnapshot;
              }
              lastTransactionNumber = transactionNumber;
              lastSnapshot = { editor, transactionNumber };
              return lastSnapshot;
          },
          /**
           * Always disable the editor on the server-side.
           */
          getServerSnapshot() {
              return { editor: null, transactionNumber: 0 };
          },
          /**
           * Subscribe to the editor instance's changes.
           */
          subscribe(callback) {
              subscribers.add(callback);
              return () => {
                  subscribers.delete(callback);
              };
          },
          /**
           * Watch the editor instance for changes.
           */
          watch(nextEditor) {
              editor = nextEditor;
              if (editor) {
                  /**
                   * This will force a re-render when the editor state changes.
                   * This is to support things like `editor.can().toggleBold()` in components that `useEditor`.
                   * This could be more efficient, but it's a good trade-off for now.
                   */
                  const fn = () => {
                      transactionNumber += 1;
                      subscribers.forEach(callback => callback());
                  };
                  const currentEditor = editor;
                  currentEditor.on('transaction', fn);
                  return () => {
                      currentEditor.off('transaction', fn);
                  };
              }
          },
      };
      return editorInstance;
  }
  function useEditorState(options) {
      const [editorInstance] = React.useState(() => makeEditorStateInstance(options.editor));
      // Using the `useSyncExternalStore` hook to sync the editor instance with the component state
      const selectedState = withSelectorExports.useSyncExternalStoreWithSelector(editorInstance.subscribe, editorInstance.getSnapshot, editorInstance.getServerSnapshot, options.selector, options.equalityFn);
      React.useEffect(() => {
          return editorInstance.watch(options.editor);
      }, [options.editor]);
      React.useDebugValue(selectedState);
      return selectedState;
  }

  const isDev = process.env.NODE_ENV !== 'production';
  const isSSR = typeof window === 'undefined';
  const isNext = isSSR || Boolean(typeof window !== 'undefined' && window.next);
  function useEditor(options = {}, deps = []) {
      const isMounted = React.useRef(false);
      const [editor, setEditor] = React.useState(() => {
          if (options.immediatelyRender === undefined) {
              if (isSSR || isNext) {
                  // TODO in the next major release, we should throw an error here
                  if (isDev) {
                      /**
                       * Throw an error in development, to make sure the developer is aware that tiptap cannot be SSR'd
                       * and that they need to set `immediatelyRender` to `false` to avoid hydration mismatches.
                       */
                      console.warn('Tiptap Error: SSR has been detected, please set `immediatelyRender` explicitly to `false` to avoid hydration mismatches.');
                  }
                  // Best faith effort in production, run the code in the legacy mode to avoid hydration mismatches and errors in production
                  return null;
              }
              // Default to immediately rendering when client-side rendering
              return new Editor(options);
          }
          if (options.immediatelyRender && isSSR && isDev) {
              // Warn in development, to make sure the developer is aware that tiptap cannot be SSR'd, set `immediatelyRender` to `false` to avoid hydration mismatches.
              throw new Error('Tiptap Error: SSR has been detected, and `immediatelyRender` has been set to `true` this is an unsupported configuration that may result in errors, explicitly set `immediatelyRender` to `false` to avoid hydration mismatches.');
          }
          if (options.immediatelyRender) {
              return new Editor(options);
          }
          return null;
      });
      React.useDebugValue(editor);
      // This effect will handle creating/updating the editor instance
      React.useEffect(() => {
          let editorInstance = editor;
          if (!editorInstance) {
              editorInstance = new Editor(options);
              // instantiate the editor if it doesn't exist
              // for ssr, this is the first time the editor is created
              setEditor(editorInstance);
          }
          else if (Array.isArray(deps) && deps.length) {
              // the deps array is used to re-initialize the editor instance
              editorInstance = new Editor(options);
              setEditor(editorInstance);
          }
          else {
              // if the editor does exist & deps are empty, we don't need to re-initialize the editor
              // we can fast-path to update the editor options on the existing instance
              editorInstance.setOptions(options);
          }
      }, deps);
      const { onBeforeCreate, onBlur, onCreate, onDestroy, onFocus, onSelectionUpdate, onTransaction, onUpdate, onContentError, } = options;
      const onBeforeCreateRef = React.useRef(onBeforeCreate);
      const onBlurRef = React.useRef(onBlur);
      const onCreateRef = React.useRef(onCreate);
      const onDestroyRef = React.useRef(onDestroy);
      const onFocusRef = React.useRef(onFocus);
      const onSelectionUpdateRef = React.useRef(onSelectionUpdate);
      const onTransactionRef = React.useRef(onTransaction);
      const onUpdateRef = React.useRef(onUpdate);
      const onContentErrorRef = React.useRef(onContentError);
      // This effect will handle updating the editor instance
      // when the event handlers change.
      React.useEffect(() => {
          if (!editor) {
              return;
          }
          if (onBeforeCreate) {
              editor.off('beforeCreate', onBeforeCreateRef.current);
              editor.on('beforeCreate', onBeforeCreate);
              onBeforeCreateRef.current = onBeforeCreate;
          }
          if (onBlur) {
              editor.off('blur', onBlurRef.current);
              editor.on('blur', onBlur);
              onBlurRef.current = onBlur;
          }
          if (onCreate) {
              editor.off('create', onCreateRef.current);
              editor.on('create', onCreate);
              onCreateRef.current = onCreate;
          }
          if (onDestroy) {
              editor.off('destroy', onDestroyRef.current);
              editor.on('destroy', onDestroy);
              onDestroyRef.current = onDestroy;
          }
          if (onFocus) {
              editor.off('focus', onFocusRef.current);
              editor.on('focus', onFocus);
              onFocusRef.current = onFocus;
          }
          if (onSelectionUpdate) {
              editor.off('selectionUpdate', onSelectionUpdateRef.current);
              editor.on('selectionUpdate', onSelectionUpdate);
              onSelectionUpdateRef.current = onSelectionUpdate;
          }
          if (onTransaction) {
              editor.off('transaction', onTransactionRef.current);
              editor.on('transaction', onTransaction);
              onTransactionRef.current = onTransaction;
          }
          if (onUpdate) {
              editor.off('update', onUpdateRef.current);
              editor.on('update', onUpdate);
              onUpdateRef.current = onUpdate;
          }
          if (onContentError) {
              editor.off('contentError', onContentErrorRef.current);
              editor.on('contentError', onContentError);
              onContentErrorRef.current = onContentError;
          }
      }, [
          onBeforeCreate,
          onBlur,
          onCreate,
          onDestroy,
          onFocus,
          onSelectionUpdate,
          onTransaction,
          onUpdate,
          onContentError,
          editor,
      ]);
      /**
       * Destroy the editor instance when the component completely unmounts
       * As opposed to the cleanup function in the effect above, this will
       * only be called when the component is removed from the DOM, since it has no deps.
       * */
      React.useEffect(() => {
          isMounted.current = true;
          return () => {
              isMounted.current = false;
              if (editor) {
                  // We need to destroy the editor asynchronously to avoid memory leaks
                  // because the editor instance is still being used in the component.
                  setTimeout(() => {
                      // re-use the editor instance if it hasn't been destroyed yet
                      // and the component is still mounted
                      // otherwise, asynchronously destroy the editor instance
                      if (!isMounted.current && !editor.isDestroyed) {
                          editor.destroy();
                      }
                  });
              }
          };
      }, []);
      // The default behavior is to re-render on each transaction
      // This is legacy behavior that will be removed in future versions
      useEditorState({
          editor,
          selector: ({ transactionNumber }) => {
              if (options.shouldRerenderOnTransaction === false) {
                  // This will prevent the editor from re-rendering on each transaction
                  return null;
              }
              // This will avoid re-rendering on the first transaction when `immediatelyRender` is set to `true`
              if (options.immediatelyRender && transactionNumber === 0) {
                  return 0;
              }
              return transactionNumber + 1;
          },
      });
      return editor;
  }

  const EditorContext = React.createContext({
      editor: null,
  });
  const EditorConsumer = EditorContext.Consumer;
  /**
   * A hook to get the current editor instance.
   */
  const useCurrentEditor = () => React.useContext(EditorContext);
  /**
   * This is the provider component for the editor.
   * It allows the editor to be accessible across the entire component tree
   * with `useCurrentEditor`.
   */
  function EditorProvider({ children, slotAfter, slotBefore, ...editorOptions }) {
      const editor = useEditor(editorOptions);
      if (!editor) {
          return null;
      }
      return (React.createElement(EditorContext.Provider, { value: { editor } },
          slotBefore,
          React.createElement(EditorConsumer, null, ({ editor: currentEditor }) => (React.createElement(EditorContent, { editor: currentEditor }))),
          children,
          slotAfter));
  }

  const BubbleMenu = (props) => {
      const [element, setElement] = React.useState(null);
      const { editor: currentEditor } = useCurrentEditor();
      React.useEffect(() => {
          var _a;
          if (!element) {
              return;
          }
          if (((_a = props.editor) === null || _a === void 0 ? void 0 : _a.isDestroyed) || (currentEditor === null || currentEditor === void 0 ? void 0 : currentEditor.isDestroyed)) {
              return;
          }
          const { pluginKey = 'bubbleMenu', editor, tippyOptions = {}, updateDelay, shouldShow = null, } = props;
          const menuEditor = editor || currentEditor;
          if (!menuEditor) {
              console.warn('BubbleMenu component is not rendered inside of an editor component or does not have editor prop.');
              return;
          }
          const plugin = extensionBubbleMenu.BubbleMenuPlugin({
              updateDelay,
              editor: menuEditor,
              element,
              pluginKey,
              shouldShow,
              tippyOptions,
          });
          menuEditor.registerPlugin(plugin);
          return () => menuEditor.unregisterPlugin(pluginKey);
      }, [props.editor, currentEditor, element]);
      return (React.createElement("div", { ref: setElement, className: props.className, style: { visibility: 'hidden' } }, props.children));
  };

  const FloatingMenu = (props) => {
      const [element, setElement] = React.useState(null);
      const { editor: currentEditor } = useCurrentEditor();
      React.useEffect(() => {
          var _a;
          if (!element) {
              return;
          }
          if (((_a = props.editor) === null || _a === void 0 ? void 0 : _a.isDestroyed) || (currentEditor === null || currentEditor === void 0 ? void 0 : currentEditor.isDestroyed)) {
              return;
          }
          const { pluginKey = 'floatingMenu', editor, tippyOptions = {}, shouldShow = null, } = props;
          const menuEditor = editor || currentEditor;
          if (!menuEditor) {
              console.warn('FloatingMenu component is not rendered inside of an editor component or does not have editor prop.');
              return;
          }
          const plugin = extensionFloatingMenu.FloatingMenuPlugin({
              pluginKey,
              editor: menuEditor,
              element,
              tippyOptions,
              shouldShow,
          });
          menuEditor.registerPlugin(plugin);
          return () => menuEditor.unregisterPlugin(pluginKey);
      }, [
          props.editor,
          currentEditor,
          element,
      ]);
      return (React.createElement("div", { ref: setElement, className: props.className, style: { visibility: 'hidden' } }, props.children));
  };

  const ReactNodeViewContext = React.createContext({
      onDragStart: undefined,
  });
  const useReactNodeView = () => React.useContext(ReactNodeViewContext);

  const NodeViewContent = props => {
      const Tag = props.as || 'div';
      const { nodeViewContentRef } = useReactNodeView();
      return (React.createElement(Tag, { ...props, ref: nodeViewContentRef, "data-node-view-content": "", style: {
              whiteSpace: 'pre-wrap',
              ...props.style,
          } }));
  };

  const NodeViewWrapper = React.forwardRef((props, ref) => {
      const { onDragStart } = useReactNodeView();
      const Tag = props.as || 'div';
      return (React.createElement(Tag, { ...props, ref: ref, "data-node-view-wrapper": "", onDragStart: onDragStart, style: {
              whiteSpace: 'normal',
              ...props.style,
          } }));
  });

  /**
   * Check if a component is a class component.
   * @param Component
   * @returns {boolean}
   */
  function isClassComponent(Component) {
      return !!(typeof Component === 'function'
          && Component.prototype
          && Component.prototype.isReactComponent);
  }
  /**
   * Check if a component is a forward ref component.
   * @param Component
   * @returns {boolean}
   */
  function isForwardRefComponent(Component) {
      var _a;
      return !!(typeof Component === 'object'
          && ((_a = Component.$$typeof) === null || _a === void 0 ? void 0 : _a.toString()) === 'Symbol(react.forward_ref)');
  }
  /**
   * The ReactRenderer class. It's responsible for rendering React components inside the editor.
   * @example
   * new ReactRenderer(MyComponent, {
   *   editor,
   *   props: {
   *     foo: 'bar',
   *   },
   *   as: 'span',
   * })
  */
  class ReactRenderer {
      constructor(component, { editor, props = {}, as = 'div', className = '', attrs, }) {
          this.ref = null;
          this.id = Math.floor(Math.random() * 0xFFFFFFFF).toString();
          this.component = component;
          this.editor = editor;
          this.props = props;
          this.element = document.createElement(as);
          this.element.classList.add('react-renderer');
          if (className) {
              this.element.classList.add(...className.split(' '));
          }
          if (attrs) {
              Object.keys(attrs).forEach(key => {
                  this.element.setAttribute(key, attrs[key]);
              });
          }
          this.render();
      }
      render() {
          var _a, _b;
          const Component = this.component;
          const props = this.props;
          if (isClassComponent(Component) || isForwardRefComponent(Component)) {
              props.ref = (ref) => {
                  this.ref = ref;
              };
          }
          this.reactElement = React.createElement(Component, { ...props });
          (_b = (_a = this.editor) === null || _a === void 0 ? void 0 : _a.contentComponent) === null || _b === void 0 ? void 0 : _b.setRenderer(this.id, this);
      }
      updateProps(props = {}) {
          this.props = {
              ...this.props,
              ...props,
          };
          this.render();
      }
      destroy() {
          var _a, _b;
          (_b = (_a = this.editor) === null || _a === void 0 ? void 0 : _a.contentComponent) === null || _b === void 0 ? void 0 : _b.removeRenderer(this.id);
      }
  }

  class ReactNodeView extends core.NodeView {
      mount() {
          const props = {
              editor: this.editor,
              node: this.node,
              decorations: this.decorations,
              selected: false,
              extension: this.extension,
              getPos: () => this.getPos(),
              updateAttributes: (attributes = {}) => this.updateAttributes(attributes),
              deleteNode: () => this.deleteNode(),
          };
          if (!this.component.displayName) {
              const capitalizeFirstChar = (string) => {
                  return string.charAt(0).toUpperCase() + string.substring(1);
              };
              this.component.displayName = capitalizeFirstChar(this.extension.name);
          }
          const ReactNodeViewProvider = componentProps => {
              const Component = this.component;
              const onDragStart = this.onDragStart.bind(this);
              const nodeViewContentRef = element => {
                  if (element && this.contentDOMElement && element.firstChild !== this.contentDOMElement) {
                      element.appendChild(this.contentDOMElement);
                  }
              };
              return (React.createElement(React.Fragment, null,
                  React.createElement(ReactNodeViewContext.Provider, { value: { onDragStart, nodeViewContentRef } },
                      React.createElement(Component, { ...componentProps }))));
          };
          ReactNodeViewProvider.displayName = 'ReactNodeView';
          if (this.node.isLeaf) {
              this.contentDOMElement = null;
          }
          else if (this.options.contentDOMElementTag) {
              this.contentDOMElement = document.createElement(this.options.contentDOMElementTag);
          }
          else {
              this.contentDOMElement = document.createElement(this.node.isInline ? 'span' : 'div');
          }
          if (this.contentDOMElement) {
              // For some reason the whiteSpace prop is not inherited properly in Chrome and Safari
              // With this fix it seems to work fine
              // See: https://github.com/ueberdosis/tiptap/issues/1197
              this.contentDOMElement.style.whiteSpace = 'inherit';
          }
          let as = this.node.isInline ? 'span' : 'div';
          if (this.options.as) {
              as = this.options.as;
          }
          const { className = '' } = this.options;
          this.handleSelectionUpdate = this.handleSelectionUpdate.bind(this);
          this.editor.on('selectionUpdate', this.handleSelectionUpdate);
          this.renderer = new ReactRenderer(ReactNodeViewProvider, {
              editor: this.editor,
              props,
              as,
              className: `node-${this.node.type.name} ${className}`.trim(),
              attrs: this.options.attrs,
          });
      }
      get dom() {
          var _a;
          if (this.renderer.element.firstElementChild
              && !((_a = this.renderer.element.firstElementChild) === null || _a === void 0 ? void 0 : _a.hasAttribute('data-node-view-wrapper'))) {
              throw Error('Please use the NodeViewWrapper component for your node view.');
          }
          return this.renderer.element;
      }
      get contentDOM() {
          if (this.node.isLeaf) {
              return null;
          }
          return this.contentDOMElement;
      }
      handleSelectionUpdate() {
          const { from, to } = this.editor.state.selection;
          if (from <= this.getPos() && to >= this.getPos() + this.node.nodeSize) {
              if (this.renderer.props.selected) {
                  return;
              }
              this.selectNode();
          }
          else {
              if (!this.renderer.props.selected) {
                  return;
              }
              this.deselectNode();
          }
      }
      update(node, decorations) {
          const updateProps = (props) => {
              this.renderer.updateProps(props);
          };
          if (node.type !== this.node.type) {
              return false;
          }
          if (typeof this.options.update === 'function') {
              const oldNode = this.node;
              const oldDecorations = this.decorations;
              this.node = node;
              this.decorations = decorations;
              return this.options.update({
                  oldNode,
                  oldDecorations,
                  newNode: node,
                  newDecorations: decorations,
                  updateProps: () => updateProps({ node, decorations }),
              });
          }
          if (node === this.node && this.decorations === decorations) {
              return true;
          }
          this.node = node;
          this.decorations = decorations;
          updateProps({ node, decorations });
          return true;
      }
      selectNode() {
          this.renderer.updateProps({
              selected: true,
          });
          this.renderer.element.classList.add('ProseMirror-selectednode');
      }
      deselectNode() {
          this.renderer.updateProps({
              selected: false,
          });
          this.renderer.element.classList.remove('ProseMirror-selectednode');
      }
      destroy() {
          this.renderer.destroy();
          this.editor.off('selectionUpdate', this.handleSelectionUpdate);
          this.contentDOMElement = null;
      }
  }
  function ReactNodeViewRenderer(component, options) {
      return (props) => {
          // try to get the parent component
          // this is important for vue devtools to show the component hierarchy correctly
          // maybe it’s `undefined` because <editor-content> isn’t rendered yet
          if (!props.editor.contentComponent) {
              return {};
          }
          return new ReactNodeView(component, props, options);
      };
  }

  exports.BubbleMenu = BubbleMenu;
  exports.Editor = Editor;
  exports.EditorConsumer = EditorConsumer;
  exports.EditorContent = EditorContent;
  exports.EditorContext = EditorContext;
  exports.EditorProvider = EditorProvider;
  exports.FloatingMenu = FloatingMenu;
  exports.NodeViewContent = NodeViewContent;
  exports.NodeViewWrapper = NodeViewWrapper;
  exports.PureEditorContent = PureEditorContent;
  exports.ReactNodeViewContext = ReactNodeViewContext;
  exports.ReactNodeViewRenderer = ReactNodeViewRenderer;
  exports.ReactRenderer = ReactRenderer;
  exports.useCurrentEditor = useCurrentEditor;
  exports.useEditor = useEditor;
  exports.useEditorState = useEditorState;
  exports.useReactNodeView = useReactNodeView;
  Object.keys(core).forEach(function (k) {
    if (k !== 'default' && !Object.prototype.hasOwnProperty.call(exports, k)) Object.defineProperty(exports, k, {
      enumerable: true,
      get: function () { return core[k]; }
    });
  });

}));
//# sourceMappingURL=index.umd.js.map
